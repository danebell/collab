package com.github.danebell.collab

import com.typesafe.scalalogging.LazyLogging
import org.clulab.odin._
import com.github.danebell.collab.mentions._

class CollabActions extends Actions with LazyLogging {

  /** Converts [[Mention]]s to [[CollabMention]]s.
    */
  def mkCollabMention(mentions: Seq[Mention], state: State): Seq[Mention] =
    mentions.map(_.toCollabMention)

  /** This action handles the creation of mentions from labels generated by the NER system.
    * Rules that use this action should run in an iteration following and rules recognizing
    * "custom" entities. This action will only create mentions if no other mentions overlap
    * with a NER label sequence.
    */
  def mkNERMentions(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions flatMap { m =>
      val candidates = state.mentionsFor(m.sentence, m.tokenInterval)
      // do any candidates overlap the mention?
      val overlap = candidates.exists(_.tokenInterval.overlaps(m.tokenInterval))
      if (overlap) None else Some(m.toCollabMention)
    }
  }
}

object CollabActions {
  def cartesianProduct(mention: Mention): Seq[Mention] = {
    //println(s"${mention.arguments.map{ case (nm, args) => s"$nm: ${args.map(_.text).mkString(", ")}"}.mkString("; ")}\n")

    val args = mention.arguments
    // sanity checks
    val numArgs = args.values.flatten.toSeq.length
    if (numArgs < 2) {
      Nil
    } else if (numArgs > 2 && args.contains("actor1") && args.contains("actor2")) {
      for {
        actor1 <- args("actor1")
        actor2 <- args("actor2")
      } yield {
        val actorArgs = Map("actor1" -> Seq(actor1), "actor2" -> Seq(actor2))
        val newArgs = (args - "actor1" - "actor2") ++ actorArgs
        mention match {
          case em: EventMention =>
            val interval = mkTokenInterval(trigger = em.trigger, arguments = newArgs)
            em.copy(tokenInterval = interval, arguments = newArgs)
          case rm: RelationMention =>
            val interval = mkTokenInterval(arguments = newArgs)
            rm.copy(tokenInterval = interval, arguments = newArgs)
        }
      }
    } else if (args.contains("actor") || args.contains("actor1")) {
      val actors = args
        .filterKeys(_.startsWith("actor"))
        .values
        .flatten
        .toSeq
      for (actorPair <- actors.combinations(2).toSeq) yield {
        val actorArgs = Map("actor1" -> Seq(actorPair.head), "actor2" -> Seq(actorPair.last))
        val newArgs = args.filterKeys(!_.startsWith("actor")) ++ actorArgs
        mention match {
          case em: EventMention =>
            val interval = mkTokenInterval(trigger = em.trigger, arguments = newArgs)
            em.copy(tokenInterval = interval, arguments = newArgs)
          case rm: RelationMention =>
            val interval = mkTokenInterval(arguments = newArgs)
            rm.copy(tokenInterval = interval, arguments = newArgs)
        }
      }
    } else Seq(mention)
  }

  def splitEvents(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions flatMap {
      case tbm: TextBoundMention => Seq(tbm)
      case em: EventMention => cartesianProduct(em)
      case rm: RelationMention => cartesianProduct(rm)
    }
  }
}