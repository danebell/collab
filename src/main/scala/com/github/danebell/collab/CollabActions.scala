package com.github.danebell.collab

import com.typesafe.scalalogging.LazyLogging
import org.clulab.odin._
import com.github.danebell.collab.mentions._

class CollabActions extends Actions with LazyLogging {

  /** Converts [[Mention]]s to [[CollabMention]]s.
    */
  def mkCollabMention(mentions: Seq[Mention], state: State): Seq[Mention] =
    mentions.map(_.toCollabMention)

  /** This action handles the creation of mentions from labels generated by the NER system.
    * Rules that use this action should run in an iteration following and rules recognizing
    * "custom" entities. This action will only create mentions if no other mentions overlap
    * with a NER label sequence.
    */
  def mkNERMentions(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions flatMap { m =>
      val candidates = state.mentionsFor(m.sentence, m.tokenInterval)
      // do any candidates overlap the mention?
      val overlap = candidates.exists(_.tokenInterval.overlaps(m.tokenInterval))
      if (overlap) None else Some(m.toCollabMention)
    }
  }
}

object CollabActions {
  def cartesianProduct(mention: Mention): Seq[Mention] = {
    //println(s"${mention.arguments.map{ case (nm, args) => s"$nm: ${args.map(_.text).mkString(", ")}"}.mkString("; ")}\n")

    val arguments = mention.arguments
    // sanity checks
    if (arguments.values.flatten.toSeq.length < 3) return Seq(mention)
    if (! arguments.contains("actor1") || ! arguments.contains("actor2")) return Seq(mention)
    for {
      actor1 <- arguments("actor1")
      actor2 <- arguments("actor2")
    } yield {
      //println(s"\tactor1: ${actor1.text}, actor2: ${actor2.text}")
      val ceArgs = Map("actor1" -> Seq(actor1), "actor2" -> Seq(actor2))
      val minArgs = (arguments - "actor1" - "actor2") ++ ceArgs
      mention match {
        case em: EventMention =>
          val interval = mkTokenInterval(trigger = em.trigger, arguments = minArgs)
          em.copy(tokenInterval = interval, arguments = minArgs)
        case rm: RelationMention =>
          val interval = mkTokenInterval(arguments = minArgs)
          rm.copy(tokenInterval = interval, arguments = minArgs)
      }
    }
  }

  def splitEvents(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions flatMap {
      case tbm: TextBoundMention => Seq(tbm)
      case em: EventMention => cartesianProduct(em)
      case rm: RelationMention => cartesianProduct(rm)
    }
  }
}